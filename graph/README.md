# Graph : 그래프

: 노드(node)와 노드 사이에 연결된 간선(edge)의 정보를 가지고 있는 자료구조

- 서로 다른 개체(객체)가 연결되어있다 => 그래프 알고리즘

- 그래프와 트리

|               | 그래프                    | 트리            |
| ------------- | ------------------------- | --------------- |
| 방향성        | 방향그래프 / 무방향그래프 | 방향 그래프     |
| 순환성        | 순환 / 비순환             | 비순환          |
| 루트노드여부  | 루트노드 없음             | 루트노드 있음   |
| 노드간 관계성 | 부모와 자식관계 없음      | 부모와 자식관계 |
| 모델의 종류   | 네트워크                  | 계층            |

- 그래프의 구현방법
  - 엣지리스트(Edge List)
    - edge를 중심으로 그래프 표현.
    - 배열에 출발노드, 도착노드를 저장하여 edge를 표현 or 출발노드, 도착노드, 가중치를 저장하여 가중치 있는 edge를 표현
    - *벨만포드, 크루스칼* 알고리즘에 사용.(노드중심 알고리즘에는 잘 사용하지 않음.)
  - 인접행렬(Adjacency Matrix)
    - 2차원 배열을 자료구조로 이용하여 그래프 표현
    - 노드중심으로 그래프 표현
    - 두 노드를 연결하는 edge의 여부와 가중치값은 배열에 직접 접근하면 확인 가능.
    - 노드 개수에 비해 edge가 적을 때는공간효율성 떨어짐.
  - **인접리스트(Adjacency List)**
    - ArrayList로 그래프 표현, 노드 개수만큼 ArrayList선언. 자료형은 경우에 맞게 사용
    - 다른 방법에 비해 구현이 복잡함
    - 노드와 연결되어있는 edge를 탐색하는 시간 매우 뛰어남. 노드 개수가 커도 공간 효율이 좋아 메모리 초과에러 발생X
    - 테스트에서 이 방식을 이용해 그래프 구현하는 것을 선호함.
- 이분그래프(bipartite graph)
  - 각 집합에 속한 노드끼리 서로 인접하지 않는 두 집합으로 그래프의 노드를 나눌 수 있을때
  - 트리의 경우 항상 이분그래프가 됌.(사이클이 발생하지 않음.)

## Union-find: 유니온 파인드

: 여러 노드가 있을때 특정 2개의 노드를 연결해 1개의 집합으로 묶는 union연산과 두 노드가 같은 집합에 속해 있는지를 확인하는 find연산으로 구성되어있는 알고리즘

```
union연산: 각 노드가 속한 집합을 1개로 합치는 연산. 노드 a,b가 a∈A, b∈B일때 union(a,b)는 A∪B
find연산: 특정 노드 a에 관해 a가 속한 집합의 대표 노드를 반환하는 연산. 노드 a가 a∈A일때 find(a)는 A집합의 대표노드를 반환
```

## Topology Sort: 위상정렬

: 사이클이 없는 방향 그래프에서 노드 순서를 찾는 알고리즘

- 시간복잡도 O(V+E). V는 노드수, E는 edge수

## Dijkstra: 다익스트라 알고리즘

: 출발노드와 모든 노드간 최단 거리 탐색, 

- edge는 모두 양수 .

- 시간복잡도 O(ElogV)

- 동작원리

  ```java
  1.인접리스트로 그래프 구현
  2.최단거리배열 초기화 (출발노드는 0, 이외 노드는 무한)
  3.최단 거리 배열에서 값이 가장 작은 노드고르기
  4.최단거리 배열 업데이트 Min(선택노드의 최단거리 배열값+edge가중치 , 연결 노드의 최단거리 배열값)
  5.3~4를 반복해 최단거리 배열 완성하기
  ```

## Bellman-ford-moore: 벨만-포드 알고리즘

: 특정 출발 노드에서 다른 모든 노드까지의 최단 경로 탐색.

- 음수 가중치 edge가 있어도 수행가능
- 전체 그래프에서 음수 사이클의 존재여부 판단 가능
- 시간복잡도 O(VE)

- 동작원리

  ```java
  1.edge리스트로 그래프 구현. 최단 경로 배열 초기화 (출발노드는 0, 나머지노드는 무한)
  2.모든edge를 확인해 정답배열 업데이트 (반복횟수는 노드갯수N-1, e종료노드, s출발노드, w가중치)
      if D[e] > D[s]+w
          then D[e] = D[s]+w
  3.음수 사이클 유무 확인 (모든 edge를 한번씩 다시 사용해 업데이트되는 노드가 발생하는지 확인. 업데이트 되는 노드 있다면 음수사이클 존재. 정답배열 무의미. 사이클 돌때마다 가중치 줄어드므로 최단거리를 찾을 수 없는 그래프)
  ```

## Floyd-warshall: 플로이드-워셜 알고리즘

: 모든 노드간에 최단 경로 탐색

- 그래프를 인접행렬로 표현

- 음수 가중치 edge가 있어도 수행가능

- 동적 계획법의 원리를 이용해 알고리즘 접근

- 시간복잡도 O(V^3)

- A노드에서 B노드까지 최단경로를 구했다고 가정했을때 최단 경로위에 K가 존재한다면 그것을 이루는 부분경로 역시 최단경로

- 구현방법

  ```java
  1.배열선언하고 초기화
      D[S][E]:노드 S에서 노드 E까지의 최단거리배열. S와 E의 값이 같은 칸은 0, 다른 칸은 무한으로 초기화
      S==E는 자기 자신에게 가는데 걸리는 최단 경로 값 의미
  2.최단거리배열에 그래프 데이터 저장
      D[S][E] = W(W는 가중치)
  3.배열 값 업데이트
      D[S][E] = Min(D[S][E], D[S][K] + D[K][E])
  ```

## Minimum spannig tree: 최소신장트리

: 그래프에서 모든 노드를 연결할때 사용된 edge들의 가중치의 합을 최소로 하는 트리

- 사이클이 포함되면 가중치의 합이 최소가 될 수 없으므로 사이클을 포함하지 않음

- N개의 노드가 있다면, 최소 신장 트리를 구성하는 edge의 개수는 항상 N-1개

- 구현방법

  ```java
  1.edge리스트로 그래프 구현하고 유니온파인드 배열 초기화
  2.그래프 데이터를 가중치 기준으로 정렬
  3.가중치가 낮은 edge부터 연결 시도
      바로 연결하는 것이 아닌 연결시 그래프에 사이클 형성 유무를 find연산으로 확인 후 사이클 되지 않을때만 union연산 이용해 연결
  4.연결한 edge의 수가 N-1이 될때까지 3 반복
  5.총 edge비용 출력하기
  ```

- 대표적으로 크루스칼 알고리즘 있음.

  - 크루스칼 알고리즘: 가장 적은비용으로 모든 노드 연결. 그리디 알고리즘으로 분류

    ```
    1.모든 간선에 대해 오름차순 정렬 수행.
    2.edge를 확인하며 edge가 사이클을 발생시키는지 확인
    	사이클이 발생하지 않는 경우 최소신장트리에 포함
    2.가장 거리가 짧은 간선부터 집합에 포함시키기
    ```

  - 시간복잡도(ElogE)